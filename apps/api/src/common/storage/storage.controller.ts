import {
    Controller,
    Post,
    Get,
    Delete,
    Query,
    UseGuards,
    UseInterceptors,
    UploadedFile,
    Req,
    Res,
    HttpException,
    HttpStatus,
    BadRequestException,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { JwtAuthGuard } from '../../auth/jwt-auth.guard';
import { RolesGuard } from '../../auth/roles.guard';
import { Roles } from '../../auth/roles.decorator';
import { StorageService, UploadFolder } from './storage.service';
import type { Request, Response } from 'express';
import { UserRole } from '@sidra/shared';

/**
 * Allowed folders for uploads.
 * Each folder has specific access control rules.
 */
const ALLOWED_FOLDERS: UploadFolder[] = ['deposits', 'teacher-docs', 'disputes', 'profile-photos', 'intro-videos', 'dispute-evidence'];

/**
 * StorageController - Handles file upload, download, and deletion.
 * 
 * Security:
 * - All endpoints require authentication
 * - File access is validated by ownership or admin role
 * - Files are NOT publicly accessible (no static serving)
 * - fileKey is generated by backend, not controlled by client
 */
@Controller('upload')
@UseGuards(JwtAuthGuard, RolesGuard)
export class StorageController {
    constructor(
        private readonly storageService: StorageService,
    ) { }

    /**
     * Upload a file.
     * 
     * POST /upload
     * Body: multipart/form-data with file and folder fields
     * Returns: { fileKey }
     */
    @Post()
    @UseInterceptors(FileInterceptor('file', {
        limits: {
            fileSize: 5 * 1024 * 1024, // 5MB
        },
    }))
    async uploadFile(
        @UploadedFile() file: Express.Multer.File,
        @Query('folder') folder: string,
        @Req() req: Request,
    ) {
        if (!file) {
            throw new BadRequestException('No file provided');
        }

        if (!ALLOWED_FOLDERS.includes(folder as UploadFolder)) {
            throw new BadRequestException(`Invalid folder. Allowed: ${ALLOWED_FOLDERS.join(', ')}`);
        }

        const userId = (req.user as any)?.userId;
        if (!userId) {
            throw new HttpException('User not authenticated', HttpStatus.UNAUTHORIZED);
        }

        try {
            // Validate file
            this.storageService.validateFile(file.buffer, file.mimetype);

            // Generate upload target
            const { fileKey, absolutePath } = this.storageService.generateUploadTarget(
                file.originalname,
                folder as UploadFolder,
                userId,
            );

            // Save file
            await this.storageService.saveFile(file.buffer, absolutePath);

            return {
                fileKey,
                message: 'File uploaded successfully',
            };
        } catch (error: any) {
            throw new BadRequestException(error.message || 'File upload failed');
        }
    }

    /**
     * Download/view a file.
     * 
     * GET /upload/file?key=...
     * Access: Owner or Admin
     */
    @Get('file')
    async getFile(
        @Query('key') fileKey: string,
        @Req() req: Request,
        @Res() res: Response,
    ) {
        if (!fileKey) {
            throw new BadRequestException('File key is required');
        }

        const userId = (req.user as any)?.userId;
        const userRole = (req.user as any)?.role;

        // Validate ownership or admin access
        const fileOwnerId = this.storageService.extractUserIdFromKey(fileKey);
        const isOwner = fileOwnerId === userId;
        const isAdmin = userRole === 'ADMIN';

        if (!isOwner && !isAdmin) {
            throw new HttpException('Access denied', HttpStatus.FORBIDDEN);
        }

        // Check if file exists
        const exists = await this.storageService.fileExists(fileKey);
        if (!exists) {
            throw new HttpException('File not found', HttpStatus.NOT_FOUND);
        }

        // Stream file to response
        const stream = this.storageService.getFileStream(fileKey);
        const contentType = this.storageService.getContentType(fileKey);

        res.set({
            'Content-Type': contentType,
            'Cache-Control': 'private, max-age=3600',
        });

        stream.pipe(res);
    }

    /**
     * Delete a file.
     * 
     * DELETE /upload?key=...
     * Access: Admin only
     */
    @Delete()
    @Roles(UserRole.ADMIN)
    async deleteFile(
        @Query('key') fileKey: string,
    ) {
        if (!fileKey) {
            throw new BadRequestException('File key is required');
        }

        const exists = await this.storageService.fileExists(fileKey);
        if (!exists) {
            throw new HttpException('File not found', HttpStatus.NOT_FOUND);
        }

        await this.storageService.deleteFile(fileKey);

        return { message: 'File deleted successfully' };
    }
}
