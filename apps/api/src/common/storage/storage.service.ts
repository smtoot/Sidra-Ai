import { Injectable, Logger } from '@nestjs/common';
import * as fs from 'fs';
import * as path from 'path';
import { Readable } from 'stream';

/**
 * Storage provider interface for future extensibility (S3, GCS, etc.)
 * Currently only local filesystem is implemented.
 */
export interface StorageProvider {
    save(buffer: Buffer, absolutePath: string): Promise<void>;
    getStream(absolutePath: string): Readable;
    delete(absolutePath: string): Promise<void>;
    exists(absolutePath: string): Promise<boolean>;
}

/**
 * Local filesystem storage provider.
 * Files are stored under UPLOAD_LOCAL_PATH environment variable.
 */
@Injectable()
export class LocalStorageProvider implements StorageProvider {
    private readonly logger = new Logger(LocalStorageProvider.name);

    async save(buffer: Buffer, absolutePath: string): Promise<void> {
        const dir = path.dirname(absolutePath);
        await fs.promises.mkdir(dir, { recursive: true });
        await fs.promises.writeFile(absolutePath, buffer);
        this.logger.log(`File saved: ${absolutePath}`);
    }

    getStream(absolutePath: string): Readable {
        return fs.createReadStream(absolutePath);
    }

    async delete(absolutePath: string): Promise<void> {
        try {
            await fs.promises.unlink(absolutePath);
            this.logger.log(`File deleted: ${absolutePath}`);
        } catch (err: any) {
            if (err.code !== 'ENOENT') {
                throw err;
            }
            // File already doesn't exist, that's fine
        }
    }

    async exists(absolutePath: string): Promise<boolean> {
        try {
            await fs.promises.access(absolutePath, fs.constants.F_OK);
            return true;
        } catch {
            return false;
        }
    }
}

/**
 * Upload target result containing file key and paths.
 */
export interface UploadTarget {
    /** Unique key for this file (stored in DB, used to retrieve file) */
    fileKey: string;
    /** Absolute path on filesystem where file should be saved */
    absolutePath: string;
}

/**
 * Allowed upload folders for access control.
 */
export type UploadFolder = 'deposits' | 'teacher-docs' | 'disputes' | 'profile-photos' | 'intro-videos' | 'dispute-evidence';

/**
 * Allowed MIME types for uploads.
 */
const ALLOWED_MIME_TYPES = [
    'image/jpeg',
    'image/png',
    'image/gif',
    'image/webp',
    'application/pdf',
    'video/mp4',
    'video/webm',
];

/**
 * Maximum file size in bytes (5MB).
 */
const MAX_FILE_SIZE = 5 * 1024 * 1024;

/**
 * StorageService - Abstract storage layer for file uploads.
 * 
 * Design decisions:
 * - fileKey is the unique identifier stored in DB (e.g., "deposits/user123/1702900000000-receipt.jpg")
 * - Actual file path is derived from fileKey + base path
 * - Provider pattern allows easy switch to S3 in future
 * - Files are NOT publicly accessible; all access goes through authenticated endpoints
 */
@Injectable()
export class StorageService {
    private readonly logger = new Logger(StorageService.name);
    private readonly basePath: string;
    private readonly provider: StorageProvider;

    constructor() {
        // Default to ./uploads in project root if not set
        this.basePath = process.env.UPLOAD_LOCAL_PATH || path.join(process.cwd(), 'uploads');
        this.provider = new LocalStorageProvider();

        // Ensure base directory exists
        fs.mkdirSync(this.basePath, { recursive: true });
        this.logger.log(`Storage initialized at: ${this.basePath}`);
    }

    /**
     * Generate upload target for a new file.
     * The fileKey is generated by the backend, not controlled by frontend.
     */
    generateUploadTarget(
        originalFileName: string,
        folder: UploadFolder,
        userId: string,
    ): UploadTarget {
        const sanitizedName = this.sanitizeFileName(originalFileName);
        const timestamp = Date.now();
        const fileKey = `${folder}/${userId}/${timestamp}-${sanitizedName}`;
        const absolutePath = path.join(this.basePath, fileKey);

        return { fileKey, absolutePath };
    }

    /**
     * Validate file before upload.
     * Throws error if validation fails.
     */
    validateFile(buffer: Buffer, mimeType: string): void {
        if (buffer.length > MAX_FILE_SIZE) {
            throw new Error(`File too large. Maximum size is ${MAX_FILE_SIZE / 1024 / 1024}MB`);
        }

        if (!ALLOWED_MIME_TYPES.includes(mimeType)) {
            throw new Error(`File type not allowed. Allowed types: ${ALLOWED_MIME_TYPES.join(', ')}`);
        }
    }

    /**
     * Save file buffer to storage.
     */
    async saveFile(buffer: Buffer, absolutePath: string): Promise<void> {
        await this.provider.save(buffer, absolutePath);
    }

    /**
     * Get readable stream for a file by its key.
     */
    getFileStream(fileKey: string): Readable {
        const absolutePath = this.getAbsolutePath(fileKey);
        return this.provider.getStream(absolutePath);
    }

    /**
     * Delete a file by its key.
     */
    async deleteFile(fileKey: string): Promise<void> {
        const absolutePath = this.getAbsolutePath(fileKey);
        await this.provider.delete(absolutePath);
    }

    /**
     * Check if a file exists by its key.
     */
    async fileExists(fileKey: string): Promise<boolean> {
        const absolutePath = this.getAbsolutePath(fileKey);
        return this.provider.exists(absolutePath);
    }

    /**
     * Extract user ID from file key for ownership validation.
     * Key format: folder/userId/timestamp-filename
     */
    extractUserIdFromKey(fileKey: string): string | null {
        const parts = fileKey.split('/');
        if (parts.length >= 2) {
            return parts[1];
        }
        return null;
    }

    /**
     * Get absolute path from file key.
     */
    private getAbsolutePath(fileKey: string): string {
        // Prevent path traversal attacks
        const normalizedKey = path.normalize(fileKey).replace(/^(\.\.(\/|\\|$))+/, '');
        return path.join(this.basePath, normalizedKey);
    }

    /**
     * Sanitize filename to prevent path traversal and special characters.
     */
    private sanitizeFileName(fileName: string): string {
        // Remove path separators, special chars, keep alphanumeric, dots, dashes, underscores
        return fileName
            .replace(/[^a-zA-Z0-9.\-_]/g, '_')
            .replace(/\.{2,}/g, '.') // No double dots
            .substring(0, 100); // Limit length
    }

    /**
     * Get content type based on file extension.
     */
    getContentType(fileKey: string): string {
        const ext = path.extname(fileKey).toLowerCase();
        const mimeTypes: Record<string, string> = {
            '.jpg': 'image/jpeg',
            '.jpeg': 'image/jpeg',
            '.png': 'image/png',
            '.gif': 'image/gif',
            '.webp': 'image/webp',
            '.pdf': 'application/pdf',
            '.mp4': 'video/mp4',
            '.webm': 'video/webm',
        };
        return mimeTypes[ext] || 'application/octet-stream';
    }
}
